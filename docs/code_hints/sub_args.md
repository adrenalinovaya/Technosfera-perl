Параметры функций
=================

Все параметры в функцию передаются через массив `@_`, но работа с его элементами напрямую (напр. `$_[2]`) — крайне нежелательна. Все параметры должны быть именованы, на это имеется два классических способа.

```perl
sub log {
  my $x = shift;
  my $base = shift // 10;
}
```

Первый способ выигрывает за счет крайне удобного способа задания значений по умолчанию.

```perl
sub log {
  my ($x, $base) = @_;
  $base //= 10;
}
```
  
Второй способ выигрывает за счет своего почти классического вида принятия параметров (имена переменных через запятую). Также `shift` подходит только для извлечения скаляров и никогда не позволит сделать что-то вроде `my ($class, %params) = @_;`.

[Прототипы](http://perldoc.perl.org/perlsub.html#Prototypes)
------------------------------------------------------------

```perl
sub execute() {}
sub log($$) {}
```

Прототипы — продвинутая фича перловых функций. Никогда не используйте их для контроля количества и типов передаваемых параметров как в других языках, они предназначены совершенно не для этого.

[Сигнатуры](http://perldoc.perl.org/perlsub.html#Signatures)
------------------------------------------------------------

```perl
sub log ($x, $base=10) {}
```

В новых версиях перла появились сигнатуры, они, в отличии от протипов, предназначены для контроля количества и типов параметров, но эта возможность все еще экспериментальная, пользоваться ей не следует.

И все-таки `@_`
---------------

Работа с элементами `@_` напрямую может иметь смысл по крайней мере в двух случаях.

* Это [сэкономит ресурсы](http://c2.com/cgi/wiki?PrematureOptimization), т. к. не будет произведено копирование.
* Вы хотите модицифировать передаваемый параметр:

```perl
sub assign_zero { $_[0] = 0 }
$x = 4;
assign_zero($x);
print $x; # Да, здесь 0
```
